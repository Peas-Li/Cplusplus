**2.1 信息存储**

计算机一般使用字节作为最小的可寻址的内存单位。

在机器级程序中不包含关于数据类型的信息。

指针的值是某个存储块的第一个字节的虚拟地址。

每个程序对象可以视为一个字节块。

一个字节有8位。

![](C:\Users\LiXiaoHui\AppData\Roaming\Typora\typora-user-images\image-20240921211122225.png)

**2.1.1 十六进制表示法**

因为二进制和十进制的转换较为麻烦，因此使用十六进制表示位模式。

十六进制以 0x 开头。

十六进制和二进制的转换：

![image-20240921205722033](C:\Users\LiXiaoHui\AppData\Roaming\Typora\typora-user-images\image-20240921205722033.png)

十六进制和十进制的转换：

![image-20240921210910104](C:\Users\LiXiaoHui\AppData\Roaming\Typora\typora-user-images\image-20240921210910104.png)

**2.1.2 字数据大小**

每个计算机有对应的字长，虚拟地址用一个字来编码，所以字长决定了虚拟地址空间的大小。64 位机器的指针类型长度为 8 字节

32位机器的虚拟地址空间为 4GB，64 位字长的虚拟地址空间位 16 EB。

int32_t 和 int64_t 类型分别为 4 字节和 8 字节，不受机器影响。使用确定大小的整数类型很有用。

对 32 位和 64 位机器而言，char、short、int、long long 长度都是一样的，为  1，2，4，8。long 的长度不一样。

float 和 double 的长度一样，分别为 4，8

程序对 char 有无符号一般不敏感。

**2.1.3 寻址和字节顺序**

对于跨越多字节的对象，它的地址是它所用字节中的最小地址。

两种字节存储法：

- 小端法：数字的低位在前（前就是最小地址）
- 大端法：数字的高位在前
- 大多数 Intel 都是小端法，不是所有。

![image-20240921212820978](C:\Users\LiXiaoHui\AppData\Roaming\Typora\typora-user-images\image-20240921212820978.png)

```c++
#include <cstdio>
#include <iostream>

using namespace std;

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len)
{
	int i;
	for(int i = 0; i < len; i++)
		printf(" %.2x", start[i]);
	printf("\n");
}

void show_int(int x)
{
	show_bytes((byte_pointer) &x, sizeof(x));
}


int main()
{
	show_int(12345);

    return 0;
}
```

**2.1.4 表示字符串**

C 语言字符串是以 null 字符结尾的字符数组，即 '\0'

![image-20240921215513154](C:\Users\LiXiaoHui\AppData\Roaming\Typora\typora-user-images\image-20240921215513154.png)

ASCII 字符适合编码英文文档。

Unicode（UTF-8）使用 **4 字节**表示字符，一些常用的字符只需要 1 或 2 个字节。所有 ASCII 字符在 UTF-8 中是一样的。

JAVA 使用 UTF-8 来编码字符串。

**2.1.5 表示代码**

二进制代码是**不兼容**的，一般无法在不同机器间移植。

从机器的角度看，**程序就是一个字节序列**。

**2.1.6 布尔代数**

**布尔代数**是在 0 和 1 基础上的定义

可以把字节看作是一个长为 8 的**位向量**。

位向量的一个应用是表示有限集合。如位向量 [0110 1001] 表示集合 A = {0,3,5,6}。

**2.1.7 C 语言中的位级运算**

位运算的常见应用是实现**掩码**。掩码表示从一个字中选出的位的集合，如掩码 0xFF 表示一个字的低 8 位。

表达式 **~0** 可以生成一个全 1 的掩码，不管机器的字大小是多少。

**2.1.8 C 语言中的逻辑运算**

逻辑运算符 && 和 || 如果第一个参数就能确定结果，就不再计算第二个参数

**2.1.9 C 语言中的移位运算**

左移 k 位丢掉最高的 k 位，并在右端补 k 个 0。

右移分为**逻辑右移**和**算术右移**。**逻辑右移左端补 0，算术右移左端补最高有效位的值。**

一般都对有符号数使用算术右移，即补符号位的值。无符号数，**只能是逻辑右移**，即补 0

**2.2 整数表示**

无符号表示与补码表示

有符号数到无符号数的转换会产生漏洞，**避免错误的方法之一是绝不使用无符号数**。

除了 C 以外**很少有语言支持无符号整数**，Java 就只支持有符号数

**2.2.1 整数数据类型**

在 64 位系统上

- i**nt**：4字节，可表示十进制数字位数：**10位（-20~20亿以内）**
- **long long**：8字节，可表示十进制数字位数：**19位（千亿亿级）**
- long：8字节
- **double**：8字节，**精度15位**，可表示十进制数字位数**308位**
- **float**：4字节，**精度6位**，可表示十进制数字**38位**
- **char**：**-128~127**

java 只支持有符号数。

**2.2.2 无符号数的编码**

无符号表示、补码表示与数据的映射都是双射，即一一对应。

**2.2.3 补码编码**

补码的定义实际就是**将符号位解释为负权**。

C 库头文件  定义了一组常量来限定不同整数数据类型的取值范围。INT_MAX、INT_MIN、UINT_MAX

C 库头文件 中定义了 uint16_t, int32_t 等类型，用于声明确定宽度类型的整数。

**2.2.4 有符号数和无符号数之间的转换**

在有符号数与无符号数之间进行强制类型转换的结果是**保持位值不变，只改变解释位的方式。**

**补码 x 转无符号数**

- x >= 0，值不变
- x < 0，转换后的值为 2^w + x

**无符号数 x 转补码**

- x < 2^(w-1)，值不变
- x >= 2^(w-1)，转换后的值为 x - 2^w

**2.2.5 C 语言中的有符号数和无符号数**

C 语言中有符号数和无符号数相加减，有符号被转换成无符号。

**2.2.6 扩展一个数字的位表示**

扩展无符号数使用零扩展，即在最高位前加 0

扩展有符号数使用符号扩展，即在最高位前加最高有效位的值

**2.2.7 截断数字**

对一个 w 位的数字截断为一个 k 位数字，将丢弃高 w-k 位。

对于无符号数而言，截断后的数字实际上等于 w mod 2^k，即取余。

**2.3 整数运算**

**2.3.1 无符号加法**

考虑溢出，C 语言不会将溢出作为错误发出信号

当 x+y >= 2^w，实际结果为 s = x+y-2^w

对任意的 x+y，**s = (x+y) % 2^w**

**溢出的结果：**和小于两个加数

**检验溢出的方式：**如果 **s，说明溢出**

**无符号数的非**：~x = 2^w - x (x>0)

**2.3.2 补码加法**

当 x+y >= 2^(w-1)， s = x+y-2^w

当 x+y < -2^(w-1)，s = x+y+2^w

**正溢出的结果是负数，负溢出的结果是正数。**

**检验溢出的方式：**当 x,y>0 而 s<=0 是正溢出；当 x,y<0 而 s>=0 是负溢出

**2.3.3 补码的非**

当 x = TMin，-x = TMin；当 x ≠ TMin，-x = -x

**补码非的位级表示：****对每一位求补，结果再加 1**

**计算补码非的第二种方法：**假设 k 是最右边的 1 的位置，对 k 左边的所有位取反

**2.3.4 无符号乘法**

**无符号乘法的积** **m = (x\*y) % 2^w**

**2.3.5 补码乘法**

可以认为补码乘法和无符号乘法的**位级表示**是一样的

C语言在运算时将 x,y 视为无符号数进行乘法运算，结果取余后将其按补码方式解释

**补码乘法的积** **m = (x\*y) % 2^w**

**2.3.6 乘以常数**

大多数机器上，整数乘法需要 **10 个或更多**的时钟周期，而加法、减法、位级运算和移位只需要 1 个时钟周期

**编译器对整数乘法进行优化的方式**：用**移位和加法或减法**运算的组合来代替常数因子的乘法。

左移 k 位等于乘以 2^k

如 x * 14  =  (x<<3)+(x<<2)+(x<<1)   =   (x<<4)-(x<<2)

**判断如何移动的方式**很简单：14 的位级表示为 1110，所以分别左移 3，2，1

**2.3.7 除以 2 的幂**

大多数机器上，整数除法更慢，需要 **30 个或更多**的始终周期。

（只有）除以 2 的幂可以用移位运算来代替，**无符号采用****逻辑右移****，补码采用****算术右移**

对于有符号数而言，算术右移的结果相当于进行除法运算后**向下舍入**

使用 **(x+(1<>k** 的结果相当于进行除法运算然后**向零舍入**

代码实现

​                (x<0 ? x+(1<<k)-1 : x) >> k;              

**2.3.8 关于整数运算的最后思考**

**补码使用了与无符号算术运算相同的位级实现**，包括加法、减法、乘法甚至除法。都有完全一样或非常类似的位级行为。

**2.3.9逆元**

满足x+x'=0，即x'为x的逆元：

无符号数：

当x=0，x'=x

当x≥0，x'=2^w-x

有符号数：
当x>-2^w，x'=-x

当x=-2^w，x'=x

**2.4 浮点数**

浮点数对于非常大，非常接近零，近似值计算都很有用

**2.4.1 二进制小数**

小数的二进制表示法只能表示那些能够写为 **x \* 2^w** 的数，**其他的数都是近似表示。x 必须可以由形如 2^i + 2^j + ... + 2^n 的多项式表示**

浮点运算的不精确性可能产生严重后果

**2.4.2 IEEE 浮点表示**

**IEEE 浮点标准**的表示形式为：**V = (-1)^S \* M \* 2^E**，它分为三部分：

1. **符号**：**S** 决定是负数还是正数
2. **阶码**：**E** 的作用是对浮点数加权
3. **尾数**：**M** 是一个二进制小数，范围是 1~2-ε 或 0~1-ε

**在对浮点数的位编码**时：

1. 一个单独的符号位编码直接编码 S
2. k 位的**阶码字段 e** 编码 E；float 中 k=8，double 中 **k=11**
3. n 位的**小数字段 f** 编码 M；float 中 n=23，double 中 **n=52**

E 和 M 的编码方式分为**三种情况**：

1. **规格化的值：**阶码字段即不全为 0 也不全为 1 时属于规格化值（0001~1110）
   1. 阶码字段解释方式：**E = e - (2^(k-1)-1)**；如 k=4 时，E 的范围是 -6~7；单精度为 -126~127
   2. 小数字段解释方式：**M = 1 + f**
2. **非规格化的值**：阶码字段全为 0 时属于非规格化形式
   1. 阶码字段解释方式：**E = 1 - (2^(k-1)-1)**；**与规格化值中 e = 1 时的 E 相同**
   2. 小数字段解释方式：**M = f**
3. **特殊值：**阶码字段全为 1 时，分两种情况：
   1. **小数字段全为 0：表示无穷**
   2. **小数字段非零：表示 NaN。**比如 ∞-∞ 的结果就返回 NaN

**2.4.3 数字示例**

0 有 +0.0 和 -0.0 两种表示方式

最大非规格化数到最小规格化数的过渡是平滑的。

浮点数能够使用正数排序函数来排序，即浮点数的位级表示当用整数方式来解释时是顺序的（正数升序负数降序）。

浮点数可表示的数的分布是不均匀的，越接近零时越稠密

**几个特殊的值的位级表示：**

1. +0.0 全为 0
2. **最小的正非规格化值：**最低有效位为 1，其他为 0
3. **最大的非规格化值：**小数字段全为 1，其他为 0
4. **最小的正规格化值：**阶码字段最低位为 1，其他为 0
5. **最大的规格化值：**阶码字段最低位为 0，符号位为 0，其他为 1

**2.4.4 舍入**

因为范围和精度有限，浮点运算只能近似表示实数运算。

在浮点数的近似匹配上，IEEE 浮点格式定义了**四种舍入方式（默认第一种）：**

1. **向偶数舍入（向最接近的值舍入）**：非中间值 (0.5) 四舍五入，中间值向偶数舍入。
2. 向零舍入
3. 向下舍入
4. 向上舍入

向偶数舍入可以计算一组数的平均数时避免统计偏差。

实际上这种舍入是发生在二进制小数上的。

**2.4.5 浮点运算**

IEEE 标准定义 1/-0 = -∞，1/+0 = +∞

浮点运算是**可交换不可结合也不可分配**的。

浮点加法满足**加法和乘法上的单调性**。如果 a>=b，则 x+a >= x+b

缺乏结合性和分配性会使一些简单问题变得很复杂

**2.4.6 C 语言中的浮点数**

在 int、float、double 间进行**强制类型转换时的几种情况：**

1. int 到 float：不会溢出，可能舍入
2. int 或 float 到 double：不会溢出也不会舍入
3. double 到 float：可能溢出和舍入
4. **float 或 double 到 int：**向零舍入，很大时可能溢出，很接近零时也可能溢出。当从浮点转换到整数时如果溢出，转变结果都为 [1000]，因此一个正浮点可能得到一个负整数

**把大的浮点数转换为整数是一种常见的错误。**

**要小心地使用浮点运算。**





**3.2 程序编码**

汇编器产生的目标代码是机器代码的一种形式，它包含二进制形式表示的所有指令，但还没有填入全局值的地址。

**3.2.1 机器级代码**

影响机器级程序的两种抽象：

- **指令集架构**：定义了处理器状态、指令的格式、指令对状态的影响。
- **虚拟地址**：机器代码将内存看成一个按字节寻址的数组。

对机器代码可见的处理器状态：

1. **程序计数器**
2. **整数寄存器文件**：保存临时数据或重要的程序状态
3. **条件码寄存器**：保存最近执行的算术或逻辑指令的状态信息。
4. **一组向量寄存器**：保存一个或多个整数或浮点数值

C 语言中的数组和结构，在机器代码中用一组连续的字节来表示。

汇编代码**不区分有符号数和无符号数，不区分指针的不同类型，不区分指针和整数**。

一条机器指令只执行一个非常基本的操作。

**3.2.2 代码示例**

**反汇编**

使用反汇编器可以根据机器代码产生汇编代码。如：48 89 d3 → mov %rdx,%rbx

机器代码与反汇编表示的特性：

1. x86-64 的指令长度范围为 1~15 字节。常用指令和操作数少的指令所需字节少。
2. 从十六进制字节值到汇编指令，格式为：某个数字唯一地对应某个汇编指令，比如 mov 指令以 48 开头。
3. 指令结尾的 'q' 是大小指示符，大多数情况下可以省略。

从源程序转换来的可执行目标文件中，除了程序过程的代码，还包含启动和终止程序的代码，与操作系统交互的代码。

链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。

**3.2.3 关于格式的注解**

在汇编代码中，以 ‘.’ (点) 开头的行是指导汇编器和链接器工作的伪指令。

**3.3 数据格式**

字节：byte，8位；字：word，16位；双字：double words，32位；四字：quad words，64位。

对应的指令后缀：movb, movw, movl, movq。

这里说的都是整数，浮点数使用一组完全不同的指令和寄存器。

**3.4 访问信息**

一个 64 位 CPU 中包含**一组 16 个存储 64 位值的通用目的寄存器**，用来存储整数和指针。

16 个寄存器标号为 **rax~rbp，r8~r15**

16 个寄存器的低位部分都可以作为字节、字、双字、四字来单独访问。分别表示为 al, ax, eax, rax。

**低位操作的规则：**

1. 将寄存器作为目标位置时，生成字节和字的指令会保持剩下的字节不变
2. 生成双字的指令会把高位四字节置为 0.

**16个寄存器的作用**

1. **rax：返回值**
2. **rsp：栈指针**
3. **rdi, rsi,** rdx, rcx,  r8, r9：第 1 到第 6 个参数
4. **rbx, rbp**, r12~r15：被调用者保存
5. r10, r11：调用者保存

**3.4.1 操作数指示符**

指令的操作数有三种类型：**立即数**（$后跟一个c语言标准规范的整数），**寄存器**，**内存引用**（（寄存器））

**最常用的寻址方式（内存引用）：Imm(rb, ri, s)：Imm + rb + ri\*s**

Imm：立即数

rb：基址寄存器

ri：变址寄存器

s ：比例因子，只能是 1，2，4，8 中的某一个

**3.4.2 数据传送指令**

**mov类**

源操作数，可以是一个立即数、一个寄存器，或者是内存引用。

目的操作数要么是一个寄存器，要么是一个内存引用，不能是立即数。

mov 只会更新目的操作数指定的寄存器字节或内存位置。

mov 类的源操作数和目的操作数不能同时为内存，即不能将值从内存复制到内存。

mov 类是最简单的数据传送指令，mov 类有 5 种：

1. movb, movw, movl：传送字节、字、双字
2. movq：传送四字。如果源操作数是立即数，只能是双字，然后符号扩展到四字（假的四字）
3. movabsq：传送绝对的四字。只能以立即数作为源操作数，以寄存器为目的。可以传送任意 64 位立即数。

movq 用来传送**寄存器和内存引用中的四字**，movabsq 用来传送**四字的立即数**

mov 指令中寄存器的大小必须与 mov 的后缀字符大小匹配：movb $-17, %al              

**movz类**

movz 系列和 movs 系列可以把较小的源值复制到较大的目的，**目的都是寄存器**。

movz 将目的寄存器剩余字节做**零扩展**，movs 做**符号扩展**

movz类：movzbw, movzbl, movzbq, movzwl, movzwq（movzbw 即从字节复制到字，其他类似）

movs类：movsbw, movsbl, movsbq, movswl, movswq, movslq, cltq

- **cltq：**没有操作数，将 eax 符号扩展到 rax，等价于 movslq %eax,%rax

















